import { type ExecSyncOptions, execSync } from "node:child_process"
import { cpSync, existsSync, mkdirSync, mkdtempSync, rmSync, writeFileSync } from "node:fs"
import os from "node:os"
import { join, resolve } from "node:path"
import { parseArgs } from "node:util"
import chalk from "chalk"
import semver from "semver"

const contentDir = "content"
const workspaceRoot = process.cwd()
const outputDir = resolve(workspaceRoot, "generated-docs")

type RunOpts = { cwd?: string; inherit?: boolean }
function run(cmd: string, opts: RunOpts = {}) {
	const exOpts: ExecSyncOptions = {
		cwd: opts.cwd,
		stdio: opts.inherit ? "inherit" : "pipe",
		encoding: "utf8",
	}
	try {
		const res = execSync(cmd, exOpts)
		if (opts.inherit) return ""
		if (typeof res === "string") return res.trim()
		return (res?.toString?.("utf8") ?? "").trim()
	} catch (err: unknown) {
		const msg = err instanceof Error ? err.message : String(err)
		throw new Error(`Command failed: ${cmd}\n${msg}`)
	}
}

const ensureDir = (p: string) => mkdirSync(p, { recursive: true })
const resetDir = (p: string) => {
	if (existsSync(p)) rmSync(p, { recursive: true, force: true })
	ensureDir(p)
}

let repoRoot = workspaceRoot
let workspaceRelativePath = ""
try {
	repoRoot = run("git rev-parse --show-toplevel")
	workspaceRelativePath = repoRoot === workspaceRoot ? "" : workspaceRoot.replace(`${repoRoot}/`, "")
} catch {
	repoRoot = workspaceRoot
	workspaceRelativePath = ""
}

// biome-ignore lint/suspicious/noConsole: TODO remove this
console.log(chalk.cyan(`Docs workspace root: ${workspaceRoot}`))
// biome-ignore lint/suspicious/noConsole: TODO remove this
console.log("outputDir:", outputDir)

const allTags = () => run("git tag --list").split("\n").filter(Boolean)

function resolveTagsFromSpec(spec: string) {
	const tags = allTags().filter((t) => semver.valid(t))
	const tokens = spec
		.split(",")
		.map((t) => t.trim())
		.filter(Boolean)
	const matched = tags.filter((tag) =>
		tokens.some((token) => semver.satisfies(tag, token, { includePrerelease: true }))
	)
	return matched.sort(semver.rcompare)
}

function buildDocs(sourceDir: string, outDir: string) {
	if (!existsSync(sourceDir)) {
		throw new Error(
			`❌ Documentation workspace not found at: ${sourceDir}
   Cannot build documentation without a valid workspace directory.`
		)
	}

	// biome-ignore lint/suspicious/noConsole: TODO remove this
	console.log(chalk.cyan(`Building docs from: ${sourceDir} → ${outDir}`))
	const docsContentDir = resolve(sourceDir, contentDir)
	if (!existsSync(docsContentDir)) {
		throw new Error(
			`❌ Content directory "${contentDir}" not found at: ${docsContentDir}
   Cannot build documentation without content files.
   Please ensure you have a "${contentDir}/" directory with your documentation content.`
		)
	}

	const packageJsonPath = resolve(sourceDir, "package.json")
	if (!existsSync(packageJsonPath)) {
		throw new Error(
			`❌ package.json not found at: ${packageJsonPath}
   Cannot build documentation without package.json.
   Please ensure your workspace has a valid package.json file.`
		)
	}

	resetDir(outDir)
	run("pnpm run content-collections:build", { cwd: sourceDir, inherit: true })

	const ccSrc = resolve(sourceDir, ".content-collections")
	const ccDest = join(outDir, ".content-collections")
	if (!existsSync(ccSrc)) {
		throw new Error(
			`❌ Build output missing at: ${ccSrc}
   Content collections build failed or did not produce output.
   Please check the build logs above for errors.`
		)
	}

	resetDir(ccDest)
	cpSync(ccSrc, ccDest, { recursive: true })

	// biome-ignore lint/suspicious/noConsole: keep for debugging
	console.log(chalk.green(`✔ Built docs → ${ccDest}`))
}

function buildRef(ref: string, labelForOutDir: string) {
	const tmpBase = mkdtempSync(resolve(os.tmpdir(), "docs-wt-"))
	const safeLabel = labelForOutDir.replace(/[^\w.-]+/g, "_")
	const worktreePath = resolve(tmpBase, safeLabel)

	run(`git worktree add --detach "${worktreePath}" "${ref}"`, {
		cwd: workspaceRoot,
		inherit: true,
	})

	try {
		const rootPkg = existsSync(resolve(worktreePath, "package.json"))
		const rootLock = existsSync(resolve(worktreePath, "pnpm-lock.yaml"))
		if (rootPkg) {
			run(`pnpm install ${rootLock ? "--frozen-lockfile" : "--no-frozen-lockfile"}`, {
				cwd: worktreePath,
				inherit: true,
			})
		}

		const sourceDir = workspaceRelativePath ? resolve(worktreePath, workspaceRelativePath) : worktreePath
		const outDir = resolve(outputDir, labelForOutDir)
		buildDocs(sourceDir, outDir)
	} finally {
		run(`git worktree remove "${worktreePath}" --force`, {
			cwd: workspaceRoot,
			inherit: true,
		})
		rmSync(tmpBase, { recursive: true, force: true })
	}
}

function buildTag(tag: string) {
	return buildRef(`refs/tags/${tag}`, tag)
}

function getCurrentBranch(): string {
	try {
		return run("git rev-parse --abbrev-ref HEAD")
	} catch {
		throw new Error("Failed to get current branch")
	}
}
;(async () => {
	const { values } = parseArgs({
		args: process.argv.slice(2),
		options: {
			versions: { type: "string" },
			// branch is now optional. If omitted, we build the current workspace
			// into `generated-docs/current`. This avoids special-casing PR / CI
			// environments vs local workflows.
			branch: { type: "string" },
		},
	})

	// branch may be provided to explicitly target a remote branch, but it
	// is optional. When omitted we simply build the current workspace into
	// `generated-docs/current` which works consistently in PRs, CI or locally.

	const rawVersions = (values.versions as string | undefined)?.trim() ?? ""
	const hasVersionsArg = rawVersions.length > 0

	let builtVersions: string[] = []

	const currentBranchToBuild = getCurrentBranch()

	// biome-ignore lint/suspicious/noConsole: keep for logging
	console.log(chalk.cyan(`Building from branch: ${currentBranchToBuild}`))

	if (hasVersionsArg) {
		const tags = resolveTagsFromSpec(rawVersions)
		if (!tags.length) throw new Error(`No tags matched spec "${rawVersions}".`)

		// biome-ignore lint/suspicious/noConsole: keep for logging
		console.log(chalk.cyan(`Building tags: ${tags.join(", ")}`))
		for (const t of tags) buildTag(t)

		// Always build the current workspace into `current`. This makes the
		// script deterministic across PRs, CI and local runs and avoids
		// having to special-case whether we're on the default branch.
		// biome-ignore lint/suspicious/noConsole: keep for logging
		console.log(chalk.cyan("Building current workspace → current"))
		buildDocs(workspaceRoot, join(outputDir, "current"))

		builtVersions = ["current", ...tags]
	} else {
		// No versions requested: just build the current workspace.
		// biome-ignore lint/suspicious/noConsole: keep for logging
		console.log(chalk.cyan("Building current workspace → current"))
		buildDocs(workspaceRoot, join(outputDir, "current"))

		builtVersions = ["current"]
	}

	const versionsFile = resolve("app/utils/versions.ts")
	writeFileSync(
		versionsFile,
		`// Auto-generated file. Do not edit manually.
export const versions = ${JSON.stringify(builtVersions, null, 2)} as const
`
	)
	// biome-ignore lint/suspicious/noConsole: keep for logging
	console.log(chalk.green(`✔ Wrote versions.ts → ${versionsFile}`))
	// biome-ignore lint/suspicious/noConsole: keep for logging
	console.log(chalk.green("✅ Done"))
})().catch((e) => {
	// biome-ignore lint/suspicious/noConsole: keep for logging
	console.error(chalk.red("❌ Build failed:"), e)
	process.exit(1)
})
